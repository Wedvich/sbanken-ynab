{"version":3,"file":"85.index.js","mappings":"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","sources":["webpack://snyk/./src/cli/commands/help/index.ts","webpack://snyk/./src/cli/commands/help/markdown-renderer.ts","webpack://snyk/./src/cli/commands/help/reflow-text.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\nimport { MethodArgs } from '../../args';\nimport { renderMarkdown } from './markdown-renderer';\n\nexport function findHelpFile(\n  helpArgs: string[],\n  helpFolderPath = '../../help/cli-commands', // this is a relative path from the webpack dist directory,\n): string {\n  while (helpArgs.length > 0) {\n    // cleanse the filename to only contain letters\n    // aka: /\\W/g but figured this was easier to read\n    const file = `${helpArgs.join('-').replace(/[^a-z0-9-]/gi, '')}.md`;\n    const testHelpAbsolutePath = path.resolve(__dirname, helpFolderPath, file);\n    if (fs.existsSync(testHelpAbsolutePath)) {\n      return testHelpAbsolutePath;\n    }\n    helpArgs = helpArgs.slice(0, -1);\n  }\n  return path.resolve(__dirname, helpFolderPath, `README.md`); // Default help file\n}\n\nexport default async function help(...args: MethodArgs): Promise<string> {\n  const helpArgs = args.filter((arg): arg is string => typeof arg === 'string');\n  const helpFileAbsolutePath = findHelpFile(helpArgs);\n  return renderMarkdown(fs.readFileSync(helpFileAbsolutePath, 'utf8'));\n}\n","import { marked } from 'marked';\nimport chalk from 'chalk';\nimport { reflowText } from './reflow-text';\n\n// stateful variable to control left-padding by header level\nlet currentHeader = 1;\nconst listItemSeparator = 'LISTITEMSEPARATOR'; // Helper string for rendering ListItems\n\n/**\n * @description get padding spaces depending on the last header level used\n * @returns string\n */\nfunction getLeftTextPadding(): string {\n  return '  '.repeat(\n    currentHeader === 1 || currentHeader === 2 ? 1 : currentHeader - 1,\n  );\n}\n\n/**\n * @description Reads current terminal width if available to limit column width for text-reflowing\n * @returns {number}\n */\nconst defaultMaximumLineWidth = 100;\nfunction getIdealTextWidth(maximumLineWidth = defaultMaximumLineWidth): number {\n  if (typeof process.stdout.columns === 'number') {\n    if (process.stdout.columns < maximumLineWidth) {\n      return process.stdout.columns - getLeftTextPadding().length - 5;\n    }\n  }\n  return maximumLineWidth - getLeftTextPadding().length;\n}\n\n// Marked custom renderer class\nconst renderer = {\n  em(text) {\n    return chalk.italic(text);\n  },\n  strong(text) {\n    return chalk.bold(text);\n  },\n  link(href, title, text) {\n    // Don't render links to relative paths (like local files)\n    if (href.startsWith('./') || !href.includes('://')) {\n      return text;\n    }\n    const renderedLink = chalk.bold.blueBright(href);\n    if (text && text !== href) {\n      return `${text} ${renderedLink}`;\n    }\n    return renderedLink;\n  },\n  blockquote(quote) {\n    return quote;\n  },\n  list(body, ordered, start) {\n    return (\n      body\n        .split(listItemSeparator)\n        .map((listItem, listItemIndex) => {\n          const bulletPoint = ordered ? `${listItemIndex + start}. ` : '-  ';\n          return reflowText(listItem, getIdealTextWidth())\n            .split('\\n')\n            .map((listItemLine, listItemLineIndex) => {\n              if (!listItemLine) {\n                return '';\n              }\n              return `${getLeftTextPadding()}${\n                listItemLineIndex === 0 ? bulletPoint : '   '\n              }${listItemLine}`;\n            })\n            .join('\\n');\n        })\n        .join('\\n') + '\\n'\n    );\n  },\n  listitem(text) {\n    return text + listItemSeparator;\n  },\n  paragraph(text) {\n    return (\n      reflowText(text, getIdealTextWidth())\n        .split('\\n')\n        .map((s) => getLeftTextPadding() + chalk.reset() + s)\n        .join('\\n') + '\\n\\n'\n    );\n  },\n  codespan(text) {\n    return chalk.italic.blueBright(`${text}`);\n  },\n  code(code) {\n    return (\n      code\n        .split('\\n')\n        .map((s) => getLeftTextPadding() + chalk.reset() + s)\n        .join('\\n') + '\\n\\n'\n    );\n  },\n  heading(text, level) {\n    currentHeader = level;\n    let coloring;\n    switch (level) {\n      case 1:\n        coloring = chalk.bold.underline;\n        break;\n      case 3:\n      case 4:\n        coloring = chalk;\n        break;\n      default:\n        coloring = chalk.bold;\n        break;\n    }\n    return `${'  '.repeat(level === 1 ? 0 : currentHeader - 2)}${coloring(\n      text,\n    )}\\n`;\n  },\n};\n\nmarked.use({ renderer });\nmarked.setOptions({\n  mangle: false,\n});\n\nconst htmlUnescapes = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\",\n  '&#96;': '`',\n  '&#x20;': '',\n};\n\n/**\n * @description Replace HTML entities with their non-encoded variant\n * @param {string} text\n * @returns {string}\n */\nfunction unescape(text: string): string {\n  Object.entries(htmlUnescapes).forEach(([escapedChar, unescapedChar]) => {\n    const escapedCharRegExp = new RegExp(escapedChar, 'g');\n    text = text.replace(escapedCharRegExp, unescapedChar);\n  });\n  return text;\n}\n\nexport function renderMarkdown(markdown: string): string {\n  return unescape(marked.parse(markdown));\n}\n","/**\nCode in this file is adapted from mikaelbr/marked-terminal\nhttps://github.com/mikaelbr/marked-terminal/blob/7501b8bb24a5ed52ec7d9114d4aeefa14f1bf5e6/index.js#L234-L330\n\n\nMIT License\n\nCopyright (c) 2017 Mikael Brevik\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\n// Compute length of str not including ANSI escape codes.\n// See http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nfunction textLength(str: string): number {\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/\\u001b\\[(?:\\d{1,3})(?:;\\d{1,3})*m/g, '').length;\n}\n\n// Munge \\n's and spaces in \"text\" so that the number of\n// characters between \\n's is less than or equal to \"width\".\nexport function reflowText(text: string, width: number): string {\n  const HARD_RETURN = '\\r|\\n';\n  const HARD_RETURN_GFM_RE = new RegExp(HARD_RETURN + '|<br ?/?>');\n\n  const splitRe = HARD_RETURN_GFM_RE;\n  const sections = text.split(splitRe);\n  const reflowed = [] as string[];\n\n  sections.forEach((section) => {\n    // Split the section by escape codes so that we can\n    // deal with them separately.\n    // eslint-disable-next-line no-control-regex\n    const fragments = section.split(/(\\u001b\\[(?:\\d{1,3})(?:;\\d{1,3})*m)/g);\n    let column = 0;\n    let currentLine = '';\n    let lastWasEscapeChar = false;\n\n    while (fragments.length) {\n      const fragment = fragments[0];\n\n      if (fragment === '') {\n        fragments.splice(0, 1);\n        lastWasEscapeChar = false;\n        continue;\n      }\n\n      // This is an escape code - leave it whole and\n      // move to the next fragment.\n      if (!textLength(fragment)) {\n        currentLine += fragment;\n        fragments.splice(0, 1);\n        lastWasEscapeChar = true;\n        continue;\n      }\n\n      const words = fragment.split(/[ \\t\\n]+/);\n\n      for (let i = 0; i < words.length; i++) {\n        let word = words[i];\n        let addSpace = column != 0;\n        if (lastWasEscapeChar) addSpace = false;\n\n        // If adding the new word overflows the required width\n        if (column + word.length > width) {\n          if (word.length <= width) {\n            // If the new word is smaller than the required width\n            // just add it at the beginning of a new line\n            reflowed.push(currentLine);\n            currentLine = word;\n            column = word.length;\n          } else {\n            // If the new word is longer than the required width\n            // split this word into smaller parts.\n            const w = word.substr(0, width - column);\n            if (addSpace) currentLine += ' ';\n            currentLine += w;\n            reflowed.push(currentLine);\n            currentLine = '';\n            column = 0;\n\n            word = word.substr(w.length);\n            while (word.length) {\n              const w = word.substr(0, width);\n\n              if (!w.length) break;\n\n              if (w.length < width) {\n                currentLine = w;\n                column = w.length;\n                break;\n              } else {\n                reflowed.push(w);\n                word = word.substr(width);\n              }\n            }\n          }\n        } else {\n          if (addSpace) {\n            currentLine += ' ';\n            column++;\n          }\n\n          currentLine += word;\n          column += word.length;\n        }\n\n        lastWasEscapeChar = false;\n      }\n\n      fragments.splice(0, 1);\n    }\n\n    if (textLength(currentLine)) reflowed.push(currentLine);\n  });\n\n  return reflowed.join('\\n');\n}\n"],"names":[],"sourceRoot":""}